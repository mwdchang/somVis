<!DOCTYPE html>
<html>
<head>
  <title>Self organizing map</title>
  <link href="style.css" rel="stylesheet">
  <script src="d3.min.js"></script>
  <script src="som.js"></script>
</head>
<body>
  <svg width="1200" height="400"></svg>
</body>
<script>

// Euclidean similarity - kind of, don't care about the sqrt since it can still
// be ordered
let similarity = (input, node) => {
  let d2 = (input.r - node.wR)*(input.r - node.wR) +
    (input.g - node.wG)*(input.g - node.wG) +
    (input.b - node.wB)*(input.b - node.wB);
  return d2;
}

let initFn = () => {
  return {
    wR: Math.random(),
    wG: Math.random(),
    wB: Math.random()
  }
}

const W = 30;
const H = 30;
let som = new SOM(W, H, initFn, similarity);


let compute = (input, t) => {
  let bestMatch = som.findBestMatch(input);
  let size = som.findNeighbourhoodSize(t);
  let rate = som.findLearnRate(t);
  let neighbours = som.findNeighbours(bestMatch, size);

  bestMatch.input = input;
  bestMatch.counter ++;

  neighbours.forEach( node => {
    let distance = som.dist(node, bestMatch);
    let influence = Math.exp( - (distance*distance)/(2*size));

    node.wR = node.wR + influence * rate * (input.r - node.wR)
    node.wG = node.wG + influence * rate * (input.g - node.wG)
    node.wB = node.wB + influence * rate * (input.b - node.wB)
  })
}


let data = [];
for (let i=0; i < 1500; i++) {
  data.push({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  })
}


let svg = d3.select('svg');

let render = (t) => {
  let dim = Math.floor(100 / W);
  let offset = t*2;
  let nodes = som.getNodes();

  let g = svg.append('g').attr('transform', 'translate(' + (offset%5)*100 + ',' + Math.floor(offset/5)*100 + ')')
  nodes.forEach( node => {
    g.append('rect')
      .attr('x', node._x * dim)
      .attr('y', node._y * dim)
      .attr('width', dim)
      .attr('height', dim)
      .style('stroke', 'none')
      .style('fill', d3.rgb(node.wR*255, node.wG*255, node.wB*255))
  })
}



let nodes = som.getNodes();
render(0);
for (let t=0.5; t <= 7; t+=0.5) {

  nodes.forEach( d => d.input = null);
  nodes.forEach( d => d.counter = 0);

  console.log(som.findLearnRate(t));
  data.forEach( d => {
    compute(d, t);
  })
  render(t);
}


let g = svg.append('g').attr('transform', 'translate(500, 0)');
nodes.forEach( node => {
  g.append('rect')
    .attr('x', node._x * 10)
    .attr('y', node._y * 10)
    .attr('width', 10)
    .attr('height', 10)
    .style('stroke', 'none')
    //.style('fill', node.input === null? 'none':  d3.rgb(node.input.r*255, node.input.g*255, node.input.b*255))
    .style('fill', node.counter === 0? 'none':  d3.rgb(node.counter*40, node.counter*40, node.counter*40))
})



/*
console.log(neighbours(nodes[0], 3))
console.log(bestMatch({r:0.5, g:0.5, b:0.5}))
console.log(neighbourhoodSize(1));
console.log(neighbourhoodSize(2));
console.log(neighbourhoodSize(3));
console.log(neighbourhoodSize(4));
*/



</script>
</html>
